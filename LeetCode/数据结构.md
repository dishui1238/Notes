# 一、数组和字符串

## 数组

### 1. 寻找数组中心索引

> 给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个

```js
// 我的
/**
 * @param {number[]} nums
 * @return {number}
 */
var pivotIndex = function (nums) {
  if (nums.length === 0) return -1;
  if (nums.length === 1) return 0;
  const sum = nums.reduce((pre, current) => pre + current);
  for (let i = 0; i < nums.length; i++) {
    let leftSum = 0;
    let rightSum = 0;
    for (let j = 0; j < i; j++) {
      leftSum += nums[j];
    }
    rightSum = sum - leftSum - nums[i];
    if (leftSum === rightSum) {
      return i;
    }
  }
  return -1;
};
```

```js
// 用时更短
var pivotIndex = function (nums) {
  let sum = 0;
  nums.forEach((num) => (sum += num));
  let leftSum = 0;
  for (i = 0; i < nums.length; i++) {
    if (sum - nums[i] - leftSum == leftSum) {
      return i;
    } else {
      leftSum += nums[i];
    }
  }
  return -1;
};
```

### 2. 搜索插入的位置

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function (nums, target) {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === target || target < nums[i]) {
      return i;
    }
  }

  return nums.length;
};
```

**二分查找**

```js
var searchInsert = function (nums, target) {
  const n = nums.length;
  let left = 0,
    right = n - 1,
    ans = n;
  while (left <= right) {
    let mid = ((right - left) >> 1) + left;
    if (target <= nums[mid]) {
      ans = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return ans;
};
```

### 3. 合并区间

> 给出一个区间的集合，请合并所有重叠的区间。

示例：

```
输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

```js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function (intervals) {
  if (intervals.length === 0) return [];
  // 1. 将数组按左边界排序
  const sortInterval = intervals.sort((a, b) => a[0] - b[0]);
  const arr = [sortInterval[0]];
  for (let i = 1; i < intervals.length; i++) {
    // 当后一项的左边界大于前一项右边界，不需合并
    if (arr[arr.length - 1][1] < intervals[i][0]) {
      arr.push(intervals[i]);
      // 如果后一项的右边界<=前一项右边界 就跳过不动 反之则进行上述方法合并
    } else if (arr[arr.length - 1][1] < intervals[i][1]) {
      arr[arr.length - 1][1] = intervals[i][1];
    }
  }
  return arr;
};
```

### 4. 旋转矩阵

> 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。不占用额外内存空间能否做到？

示例：

```
给定 matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

思路：先将矩阵转置，然后将每一行倒序 reverse

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function (matrix) {
  for (i = 0; i < matrix.length; i++) {
    for (j = i + 1; j < matrix.length; j++) {
      const temp = matrix[i][j];
      matrix[i][j] = matrix[j][i];
      matrix[j][i] = temp;
    }
    matrix[i] = matrix[i].reverse();
  }
  return matrix;
};
```

### 5. 零矩阵

> 编写一种算法，若 M × N 矩阵中某个元素为 0，则将其所在的行与列清零。

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) {
  let xClear = new Set(), // 存储需要清除的行索引
    yClear = new Set(); // 存储需要清除的列索引
  for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[i].length; j++) {
      if (matrix[i][j] === 0) {
        xClear.add(i);
        yClear.add(j);
      }
    }
  }

  // 清除行
  for (let i of xClear) {
    for (let j = 0; j < matrix[i].length; j++) {
      matrix[i][j] = 0;
    }
  }

  // 清除列
  for (let j of yClear) {
    for (let i = 0; i < matrix.length; i++) {
      matrix[i][j] = 0;
    }
  }
};
```

### 6. 对角线遍历

> 给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

```

## 字符串

### 1. 最长公共前缀

> 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。

```
输入: ["flower","flow","flight"]
输出: "fl"
```

```js
var longestCommonPrefix = function (strs) {
  const len = strs.length;
  const newStrs = strs.map((i) => {
    return i.split("");
  });

  if (len === 0) return "";
  if (len === 1) return strs[0];

  const commonPrefix = [];
  // 以第一个来对比
  for (let i = 0; i < newStrs[0].length; i++) {
    if (strs.every((item) => item[i] === newStrs[0][i])) {
      commonPrefix.push(newStrs[0][i]);
    } else {
      break;
    }
  }
  return commonPrefix.join("");
};
```
