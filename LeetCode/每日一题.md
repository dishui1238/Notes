<!--
 * @Author: your name
 * @Date: 2020-11-26 10:03:45
 * @LastEditTime: 2020-12-30 09:42:37
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \0dailyUpdateNotes\Notes\LeetCode\每日一题.md
-->

### 1. 最大间距

```
给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。
如果数组元素个数小于 2，则返回 0。
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumGap = function (nums) {
  let maximumGap = 0;
  if (nums.length < 2) return 0;
  let numsCopy = nums.sort((a, b) => a - b);
  for (let i = 1; i < nums.length; i++) {
    maximumGap =
      numsCopy[i] - numsCopy[i - 1] > maximumGap
        ? numsCopy[i] - numsCopy[i - 1]
        : maximumGap;
  }
  return maximumGap;
};
```

### 2. 重构字符串

```
给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。
若可行，输出任意可行的结果。若不可行，返回空字符串
注意：S 只包含小写字母并且长度在[1, 500]区间内。
```

思路：
典型的贪心算法的题

- 当 n 是偶数时，有 n/2 个偶数下标和 n/2 个奇数下标，因此每个字母的出现次数都不能超过 n/2 次，否则出现次数最多的字母一定会出现相邻。

- 当 n 是奇数时，由于共有 (n+1)/2 个偶数下标，因此每个字母的出现次数都不能超过 (n+1)/2 次，否则出现次数最多的字母一定会出现相邻。

- 由于当 n 是偶数时，在整数除法下满足 n/2 和 (n+1)/2 相等，因此可以合并 n 是偶数与 n 是奇数的情况：如果可以重新排布成相邻的字母都不相同的字符串，每个字母最多出现 (n+1)/2 次。

- 如果字母的出现次数大于 0 且小于或等于 n/2，且 oddIndex 没有超出数组下标范围，则将字母放置在 oddIndex，然后将 oddIndex 的值加 2。

- 如果字母的出现次数大于 n/2，或 oddIndex 超出数组下标范围，则将字母放置在 evenIndex，然后将 evenIndex 的值加 2。

```js
/**
 * @param {string} S
 * @return {string}
 */
var reorganizeString = function (S) {
  const len = S.length;
  let bucket = {}; // {a: 2, b: 3}

  // 遍历 S 将每个字母放入 bucket 中，记录其出现次数
  S.split("").forEach((s) => {
    if (bucket[s]) {
      bucket[s] += 1;
    } else {
      bucket[s] = 1;
    }
  });

  // 将字符依照出现次数排序，找出出现次数最多的字符
  let bucketArr = []; // [{key: key, num: 1},{}...]
  for (s in bucket) {
    bucketArr.push({
      key: s,
      num: bucket[s],
    });
  }
  bucketArr = bucketArr.sort((a, b) => b.num - a.num);

  // 如果最大出现次数 > len+1/2 则返回空字符串
  if (bucketArr[0].num > Math.floor((len + 1) / 2)) {
    return "";
  }

  // 否则就开始拼接字符串: 从大到小 依次取两个值进行拼接
  let ans = [];

  for (let i = 0; i < bucketArr[0].num; i++) {
    ans.push(bucketArr[0].key);
  }

  let cur = 1; // 当前遍历 bucketArr 的索引
  let i = 1; // 插入的 ans 位置的索引
  while (cur < bucketArr.length) {
    ans.splice(i, 0, bucketArr[cur].key);
    bucketArr[cur].num--;
    if (!bucketArr[cur].num) {
      cur++;
    }
    //隔一个插入
    i += 2;
    if (i >= ans.length + 1) {
      //注意：如果是超出一位的话，也是可以的，因为插到最后，就是超出一位
      i = 1;
    }
  }

  return ans.join("");
};
```

### 3.移掉 K 位数字

```
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小
num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。
```

```
思路：这里有一个前置知识：对于两个数 123a456 和 123b456，如果 a > b， 那么数字 123a456 大于 数字 123b456，否则数字 123a456 小于等于数字 123b456。也就说，两个相同位数的数字大小关系取决于第一个不同的数的大小

```

```js
/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var removeKdigits = function (num, k) {
  const stack = []; // 栈，用来存储留下的数字，单调不递减
  for (let i = 0; i < num.length; i++) {
    // 出栈：当前数比栈顶的数小，删栈顶的数 且 k > 0
    while (k > 0 && stack.length && num[i] < stack[stack.length - 1]) {
      stack.pop();
      k--;
    }
    // 入栈：去反(栈为空且当前字符为 "0" 时，不入栈)
    if (stack.length !== 0 || num[i] !== "0") {
      stack.push(num[i]);
    }
  }
  // 遍历结束后，如果还没删够 k 个字符，开一个循环继续出栈，删掉低位。
  while (k > 0) {
    stack.pop();
    k--;
  }
  return stack.length ? stack.join("") : "0";
};
```

### 4.TODO-拼接最大数

```
给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组
```

```
方法： 单调栈

思路：
1. nums1 的长度为 m, nums2 的长度为 n, 从 nums1 中选出长度为 x 的子序列，x 需满足 [max(0, k-n), min(k, n)]，nums2 中选出长度为 y 的子序列，y = k-x
2. 遍历所有可能 x, y 的值，对于每一组 x, y 取其最大数，即 第一步是分别从两个数组中得到指定长度的最大子序列，第二步是将两个最大子序列合并。
3. 比较所有最大数的值，取其中最大数
```

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[]}
 */
var maxNumber = function (nums1, nums2, k) {
  const m = nums1.length,
    n = nums2.length;
  const start = max(0, k - n),
    end = min(k, n);
  for (let x = start; x < end; x++) {
    const subsequence1 = MaxSubsequence(nums1, x);
    const subsequence2 = MaxSubsequence(nums1, k - x);
    // 合并两个最大子序列
  }
};

var MaxSubsequence = function (nums, k) {
  const length = nums.length;
  const stack = [];
};
```

### 5.二叉树的锯齿形层序遍历

```
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：
[
  [3],
  [20,9],
  [15,7]
]
```

层序：第 k 层，需要 2^k 个数据

```js
var zigzagLevelOrder = function (root) {};
```

### 6.买卖股票的最佳时机

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。
```

示例 1:

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

```ts
// 单次遍历
function maxProfit(prices: number[]): number {
  let minPrice: number = prices[0];
  let maxProfit: number = 0;
  for (let i = 0; i < prices.length; i++) {
    if (prices[i] < minPrice) {
      minPrice = prices[i];
    } else if (prices[i] - minPrice > maxProfit) {
      maxProfit = prices[i] - minPrice;
    }
  }

  return maxProfit;
}
```

### 7.两数之和

```
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例：
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

```js
/** 两次遍历
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
  const len = nums.length;
  for (let i = 0; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      if (nums[j] === target - nums[i]) {
        return [i, j];
      }
    }
  }
};
```

方法二：
用 hashMap 存储遍历过的元素和对应的索引。
每遍历一个元素，看看 hashMap 中是否存在满足要求的目标数字。
所有事情在一次遍历中完成（用了空间换取时间）

```js
/** 哈希表
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
  const hashMap = {}; // 存储遍历过的数据 { num: index }

  for (let i = 0; i < nums.length; i++) {
    if (hashMap[target - nums[i]] === undefined) {
      hashMap[nums[i]] = i;
    } else {
      return [i, hashMap[target - nums[i]]];
    }
  }
};
```

### 8.两数之和

