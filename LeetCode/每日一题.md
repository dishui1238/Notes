<!--
 * @Author: your name
 * @Date: 2020-11-26 10:03:45
 * @LastEditTime: 2020-12-07 17:33:28
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \0dailyUpdateNotes\Notes\LeetCode\每日一题.md
-->

### 1. 最大间距

```
给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。
如果数组元素个数小于 2，则返回 0。
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumGap = function (nums) {
  let maximumGap = 0;
  if (nums.length < 2) return 0;
  let numsCopy = nums.sort((a, b) => a - b);
  for (let i = 1; i < nums.length; i++) {
    maximumGap =
      numsCopy[i] - numsCopy[i - 1] > maximumGap
        ? numsCopy[i] - numsCopy[i - 1]
        : maximumGap;
  }
  return maximumGap;
};
```

### 2. 重构字符串

```
给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。
若可行，输出任意可行的结果。若不可行，返回空字符串
注意：S 只包含小写字母并且长度在[1, 500]区间内。
```

思路：
典型的贪心算法的题

- 当 n 是偶数时，有 n/2 个偶数下标和 n/2 个奇数下标，因此每个字母的出现次数都不能超过 n/2 次，否则出现次数最多的字母一定会出现相邻。

- 当 n 是奇数时，由于共有 (n+1)/2 个偶数下标，因此每个字母的出现次数都不能超过 (n+1)/2 次，否则出现次数最多的字母一定会出现相邻。

- 由于当 n 是偶数时，在整数除法下满足 n/2 和 (n+1)/2 相等，因此可以合并 n 是偶数与 n 是奇数的情况：如果可以重新排布成相邻的字母都不相同的字符串，每个字母最多出现 (n+1)/2 次。

- 如果字母的出现次数大于 0 且小于或等于 n/2，且 oddIndex 没有超出数组下标范围，则将字母放置在 oddIndex，然后将 oddIndex 的值加 2。

- 如果字母的出现次数大于 n/2，或 oddIndex 超出数组下标范围，则将字母放置在 evenIndex，然后将 evenIndex 的值加 2。

```js
/**
 * @param {string} S
 * @return {string}
 */
var reorganizeString = function (S) {
  const len = S.length;
  let bucket = {}; // {a: 2, b: 3}

  // 遍历 S 将每个字母放入 bucket 中，记录其出现次数
  S.split("").forEach((s) => {
    if (bucket[s]) {
      bucket[s] += 1;
    } else {
      bucket[s] = 1;
    }
  });

  // 将字符依照出现次数排序，找出出现次数最多的字符
  let bucketArr = []; // [{key: key, num: 1},{}...]
  for (s in bucket) {
    bucketArr.push({
      key: s,
      num: bucket[s],
    });
  }
  bucketArr = bucketArr.sort((a, b) => b.num - a.num);

  // 如果最大出现次数 > len+1/2 则返回空字符串
  if (bucketArr[0].num > Math.floor((len + 1) / 2)) {
    return "";
  }

  // 否则就开始拼接字符串: 从大到小 依次取两个值进行拼接
  let ans = [];

  for (let i = 0; i < bucketArr[0].num; i++) {
    ans.push(bucketArr[0].key);
  }

  let cur = 1; // 当前遍历 bucketArr 的索引
  let i = 1; // 插入的 ans 位置的索引
  while (cur < bucketArr.length) {
    ans.splice(i, 0, bucketArr[cur].key);
    bucketArr[cur].num--;
    if (!bucketArr[cur].num) {
      cur++;
    }
    //隔一个插入
    i += 2;
    if (i >= ans.length + 1) {
      //注意：如果是超出一位的话，也是可以的，因为插到最后，就是超出一位
      i = 1;
    }
  }

  return ans.join("");
};
```

### 3.移掉 K 位数字

```
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小
num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。
```

```
思路：这里有一个前置知识：对于两个数 123a456 和 123b456，如果 a > b， 那么数字 123a456 大于 数字 123b456，否则数字 123a456 小于等于数字 123b456。也就说，两个相同位数的数字大小关系取决于第一个不同的数的大小

```

```js
/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var removeKdigits = function (num, k) {
  const stack = []; // 栈，用来存储留下的数字，单调不递减
  for (let i = 0; i < num.length; i++) {
    // 出栈：当前数比栈顶的数小，删栈顶的数 且 k > 0
    while (k > 0 && stack.length && num[i] < stack[stack.length - 1]) {
      stack.pop();
      k--;
    }
    // 入栈：去反(栈为空且当前字符为 "0" 时，不入栈)
    if (stack.length !== 0 || num[i] !== "0") {
      stack.push(num[i]);
    }
  }
  // 遍历结束后，如果还没删够 k 个字符，开一个循环继续出栈，删掉低位。
  while (k > 0) {
    stack.pop();
    k--;
  }
  return stack.length ? stack.join("") : '0';
};
```

### 4.TODO-拼接最大数

```
给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组
```

```
方法： 单调栈

思路：
1. nums1 的长度为 m, nums2 的长度为 n, 从 nums1 中选出长度为 x 的子序列，x 需满足 [max(0, k-n), min(k, n)]，nums2 中选出长度为 y 的子序列，y = k-x
2. 遍历所有可能 x, y 的值，对于每一组 x, y 取其最大数，即 第一步是分别从两个数组中得到指定长度的最大子序列，第二步是将两个最大子序列合并。
3. 比较所有最大数的值，取其中最大数
```

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[]}
 */
var maxNumber = function (nums1, nums2, k) {
  const m = nums1.length,
    n = nums2.length;
  const start = max(0, k - n),
    end = min(k, n);
  for (let x = start; x < end; x++) {
    const subsequence1 = MaxSubsequence(nums1, x);
    const subsequence2 = MaxSubsequence(nums1, k - x);
    // 合并两个最大子序列
  }
};

var MaxSubsequence = function (nums, k) {
  const length = nums.length;
  const stack = [];

};
```


### 5.二叉树的锯齿形层序遍历

```
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层序遍历如下：
[
  [3],
  [20,9],
  [15,7]
]
```
层序：第 k 层，需要 2^k 个数据


```js
var zigzagLevelOrder = function(root) {

};
```